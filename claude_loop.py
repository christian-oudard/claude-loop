#!/usr/bin/env python3
"""Coding loop for Claude Code.

Provides a stop hook that re-prompts Claude with the task after each iteration,
with a verification step before completion.

Usage:
    claude-loop           Start the loop (called by /loop slash command)
    claude-loop hook      Stop hook handler (called by Claude Code)
    claude-loop stop      Cancel a running loop
"""

from pathlib import Path
import json
import re
import sys
import os

INITIAL_PROMPT = """\
Loop activated. Work incrementally: implement one piece, verify it, then \
stop. You will be re-prompted with the task after each iteration.

## Task

{prompt}
"""

CONTINUATION_PROMPT = """\
# Loop iteration

You are in a coding loop. Your context may have been compacted — do not \
assume you remember prior iterations. Re-orient yourself by reading files \
and checking git status/log to understand what has already been done.

Work incrementally: pick one concrete piece of the task, implement it, and \
verify it works (run tests, lint, or inspect output). Then stop. Do not try \
to finish everything in one iteration.

## Early completion

If the task is genuinely and fully complete, output exactly the words \
TASK_COMPLETE as a standalone message (nothing else).

You MUST NOT output this unless the task is unequivocally done. Do not use \
it to escape the loop because you feel stuck, think the task is impossible, \
or want to stop for any other reason. If you are stuck, use the next \
iteration to try a different approach. The loop exists to give you multiple \
attempts — use them.

## Task

{prompt}
"""

VERIFICATION_PROMPT = """\
# Verification iteration

You indicated the task is complete. Before confirming, do a thorough review:

1. Re-read the original task requirements below.
2. Read through all code you wrote or modified.
3. Run the tests or otherwise verify the implementation works end-to-end.
4. Check for edge cases, missing requirements, or loose ends.

After your review, output exactly one of these keywords as a standalone \
message:

- REVIEW_OKAY — the task is fully and genuinely complete.
- REVIEW_INCOMPLETE — you found something incomplete or broken. Briefly \
describe what remains before the keyword.

## Task

{prompt}
"""


def main():
    if len(sys.argv) > 1 and sys.argv[1] == 'hook':
        hook()
    elif len(sys.argv) > 1 and sys.argv[1] == 'stop':
        delete_loop_file()
        print('Loop stopped.')
    else:
        start()


def start():
    # Write a placeholder loop file. The first hook invocation will fill in
    # the prompt from the transcript (which it gets reliably via the event).
    write_loop_file(0, None)


def hook():
    # Check whether there is a loop file.
    loop_data = read_loop_file()
    if loop_data is None:
        return

    # Only catch Stop hooks.
    event = json.loads(sys.stdin.read())
    if event['hook_event_name'] != 'Stop':
        return

    transcript_path = event.get('transcript_path')

    # On the first hook call, the prompt is null — parse it from the transcript.
    # If parsing fails (stray loop.json from a previous session), clean up silently.
    first = loop_data['prompt'] is None
    if first:
        result = parse_loop_args(transcript_path)
        if result is None or result == 'stop':
            delete_loop_file()
            return
        n, prompt = result
    else:
        n = loop_data['n']
        prompt = loop_data['prompt']

    n -= 1

    # Check whether there was a completion keyword given by the agent.
    last_msg = event.get('last_assistant_message', '')
    keyword = find_keyword(last_msg)

    if n <= 0:
        # Iterations exhausted — end the loop.
        delete_loop_file()
        print(json.dumps({
            "decision": "block",
            "reason": "Loop complete (iterations exhausted). Summarize what you accomplished.",
        }))
    elif keyword == 'REVIEW_OKAY':
        # Verified complete — end the loop.
        delete_loop_file()
        print(json.dumps({
            "decision": "block",
            "reason": "Loop complete (verified). Summarize what you accomplished.",
        }))
    elif keyword == 'TASK_COMPLETE':
        # First claim — enter verification iteration.
        write_loop_file(n, prompt)
        print(json.dumps({
            "decision": "block",
            "reason": VERIFICATION_PROMPT.format(prompt=prompt),
        }))
    else:
        # Normal continuation. Covers REVIEW_INCOMPLETE, no keyword, and first call.
        write_loop_file(n, prompt)
        reason = INITIAL_PROMPT if first else CONTINUATION_PROMPT
        print(json.dumps({
            "decision": "block",
            "reason": reason.format(prompt=prompt),
        }))


# Loop file management.

def read_loop_file():
    path = loop_file_path()
    if path.exists():
        return json.load(path.open())


def write_loop_file(n, prompt):
    json.dump({'n': n, 'prompt': prompt}, loop_file_path().open('w'))


def delete_loop_file():
    loop_file_path().unlink(missing_ok=True)


def loop_file_path():
    return dot_claude_dir() / 'loop.json'


def dot_claude_dir():
    p = Path.cwd()
    for p in [p, *p.parents]:
        if p == Path.home():
            break
        dot_claude = p / '.claude'
        if dot_claude.exists():
            return dot_claude

    print("Not in a project, or there is no .claude directory.", file=sys.stderr)
    sys.exit(1)


# Transcript parsing.

def parse_loop_args(transcript_path):
    """Find the /loop invocation in the transcript and return (n, prompt)."""
    for line in reverse_lines(transcript_path):
        msg = json.loads(line)
        if msg.get('type') != 'user':
            continue
        content = msg.get('message', {}).get('content')
        if not isinstance(content, str):
            continue
        m = re.search(
            r'<command-name>/loop</command-name>.*?<command-args>(.*?)</command-args>',
            content, re.DOTALL,
        )
        if m:
            args = m.group(1).strip()
            if args == 'stop':
                return 'stop'
            parts = args.split(None, 1)
            assert len(parts) == 2, "Expected: /loop NUM_ITERATIONS TASK"
            return int(parts[0]), parts[1]

    return None


def find_keyword(text):
    """Check text for a loop keyword.

    Returns 'TASK_COMPLETE', 'REVIEW_OKAY', 'REVIEW_INCOMPLETE', or None.
    """
    for kw in ('TASK_COMPLETE', 'REVIEW_OKAY', 'REVIEW_INCOMPLETE'):
        if kw in text:
            return kw
    return None


def reverse_lines(path, block_size=4096):
    """Yield lines from a file in reverse order."""
    size = os.path.getsize(path)
    if size == 0:
        return
    with open(path, 'rb') as f:
        remainder = b''
        pos = size
        while pos > 0:
            read_size = min(block_size, pos)
            pos -= read_size
            f.seek(pos)
            chunk = f.read(read_size) + remainder
            lines = chunk.split(b'\n')
            remainder = lines[0] if pos > 0 else b''
            start = 1 if pos > 0 else 0
            for line in reversed(lines[start:]):
                line = line.strip()
                if line:
                    yield line.decode()
        if remainder.strip():
            yield remainder.strip().decode()


if __name__ == '__main__':
    main()
